{"version":1,"ops":[{"type":5,"author":{"name":"Michael Muré","email":"","login":"MichaelMure","avatar_url":"https://avatars1.githubusercontent.com/u/294669?v=4"},"timestamp":1538494591,"metadata":{"github-id":"MDEyOkxhYmVsZWRFdmVudDE4Nzk2Nzg5ODc="},"added":["enhancement"],"removed":null},{"type":3,"author":{"name":"anarcat","email":"","login":"anarcat","avatar_url":"https://avatars3.githubusercontent.com/u/796623?v=4"},"timestamp":1538509051,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQyNjQwMzAwOQ=="},"message":"this is a followup to #7 which does the opposite, of course.","files":null},{"type":3,"author":{"name":"Cristian Filipov","email":"","login":"cfilipov","avatar_url":"https://avatars3.githubusercontent.com/u/5324653?v=4"},"timestamp":1539376792,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQyOTQ1NTY1Nw=="},"message":"Looking at the GitHub API I don't see any way to set the created timestamp on an issue using either the rest api or graphql. This means that unfortunately timestamps of all issues exported to github will not match what's in git-bug. This may also be a problem for syncing, which time stamp is treated as authoritative?","files":null},{"type":3,"author":{"name":"Michael Muré","email":"","login":"MichaelMure","avatar_url":"https://avatars1.githubusercontent.com/u/294669?v=4"},"timestamp":1539378109,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQyOTQ2MTEzMA=="},"message":"@cfilipov It won't be a problem for syncing.\n\nThe Github importer is tagging operation in git-bug with the corresponding id on Github (for example: https://github.com/MichaelMure/git-bug/blob/master/bridge/github/import.go#L134). When doing an import again, the importer will look for this tag to recognize an already imported event and import what is missing.\n\nFor the exporter it's a little trickier because you can't tag an already persisted operation, the data model is immutable. What is possible though is to create a new operation (let's call it `SetMetadataOperation`) that will tag retroactively another operation (the same way `EditCommentOperation` operate on a previous comment). When a bug is compiled into a snapshot, this new operation will append the new tag into a previously defined operation.\n\nThe Github exporter will replicate the operation stored in git-bug through the Github API and then add in git-bug a series of `SetMetadataOperation` to tag retroactively the operation with the corresponding Github id. When doing another export, only the operation that are not tagged will be replicated on Github.\n\nSo yes, the timestamp won't match exactly but I don't think that it will be that much of a problem, especially if the exporter is ran automatically after each edit.","files":null},{"type":3,"author":{"name":"Michael Muré","email":"","login":"MichaelMure","avatar_url":"https://avatars1.githubusercontent.com/u/294669?v=4"},"timestamp":1539378324,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQyOTQ2MjAyMQ=="},"message":"Alternatively, the exporter could also use the [NoOpOperation](https://github.com/MichaelMure/git-bug/blob/master/bug/op_noop.go) to store arbitrary metadata in an issue timeline without doing any changes.","files":null},{"type":3,"author":{"name":"Michael Muré","email":"","login":"MichaelMure","avatar_url":"https://avatars1.githubusercontent.com/u/294669?v=4"},"timestamp":1539378419,"metadata":{"github-id":"MDEyOklzc3VlQ29tbWVudDQyOTQ2MjQyMA=="},"message":"@cfilipov Btw, if you want to give it a try you are more than welcome, I probably won't have time to work on it for a while as I just started a new job.","files":null}]}